{
    "collab_server" : "",
    "contents" : "#include \"wsrf.h\"\n\n#if defined WSRF_USE_BOOST || defined WSRF_USE_C11\n#ifdef WSRF_USE_BOOST\n#include <boost/thread.hpp>\n#include <boost/bind.hpp>\n#include <boost/chrono.hpp>\n#include <boost/exception_ptr.hpp>\n#else\n#include <thread>\n#include <chrono>\n#include <future>\n#endif\n#endif\n\n\nusing namespace std;\n\n/*\n * Main entry function for building random forests model.\n */\nSEXP wsrf (\n    SEXP dsSEXP,         // Data.\n    SEXP tnSEXP,         // Target variable name.\n    SEXP ntreesSEXP,     // Number of trees.\n    SEXP nvarsSEXP,      // Number of variables.\n    SEXP weightsSEXP,    // Whether use weights.\n    SEXP parallelSEXP,   // Whether parallel or how many cores performing parallelism.\n    SEXP seedsSEXP,      // Random seeds for each cores.\n    SEXP importanceSEXP, // Whether calculate variable importance measures.\n    SEXP ispartSEXP      // Indicating whether it is part of the whole forests.\n    ) {\n    BEGIN_RCPP\n\n        bool            ispart      = Rcpp::as<bool>(ispartSEXP);\n\n        Rcpp::DataFrame ds           (dsSEXP);\n        MetaData        meta_data    (ds, Rcpp::as<string>(tnSEXP));\n        TargetData      targ_data    (ds, &meta_data);\n        Dataset         train_set    (ds, &meta_data, true);\n        RForest         rf           (&train_set,\n                                      &targ_data,\n                                      &meta_data,\n                                      Rcpp::as<int>(ntreesSEXP),\n                                      Rcpp::as<int>(nvarsSEXP),\n                                      Rcpp::as<bool>(weightsSEXP),\n                                      Rcpp::as<bool>(importanceSEXP),\n                                      seedsSEXP);\n\n        volatile bool interrupt = false;\n\n#if defined WSRF_USE_BOOST || defined WSRF_USE_C11\n        int nthreads       = Rcpp::as<int>(parallelSEXP);\n#ifdef WSRF_USE_BOOST\n        int nCoresMinusTwo = boost::thread::hardware_concurrency() - 2;\n#else\n        int nCoresMinusTwo = thread::hardware_concurrency() - 2;\n#endif\n        if (nthreads == 0 || nthreads == 1 || (nthreads < 0 && nCoresMinusTwo == 1)) {  // build trees sequentially\n\n            rf.buidForestSeq(&interrupt);\n\n        } else {  // run in parallel\n\n            /**\n             * create a thread for model building\n             * leave main thread for interrupt check once per 100 milliseconds\n             *\n             * <interrupt> is used to inform each thread of no need to continue, but has 2 roles:\n             *  1. represents user interrupt\n             *  2. represents a exception has been thrown from one tree builder\n             */\n#ifdef WSRF_USE_BOOST\n            boost::packaged_task<void> pt(boost::bind(&RForest::buildForestAsync, &rf, nthreads, &interrupt));\n            boost::unique_future<void> res = pt.get_future();\n            boost::thread task(boost::move(pt));\n#else  // #ifdef WSRF_USE_BOOST\n            future<void> res = async(launch::async, &RForest::buildForestAsync, &rf, nthreads, &interrupt);\n#endif  // #ifdef WSRF_USE_BOOST\n            try {\n\n                while (true) {\n//                  this_thread::sleep_for(chrono::seconds {1});\n\n                    // check interruption\n                    if (check_interrupt()) {\n                        interrupt = true;\n                        throw interrupt_exception(\"The random forest model building is interrupted.\");\n                    }\n\n                    // check RF thread completion\n#ifdef WSRF_USE_BOOST\n                    if (res.wait_for(boost::chrono::milliseconds (100)) == boost::future_status::ready) {\n#else  // #ifdef WSRF_USE_BOOST\n\n#if (defined(__GNUC__) && __GNUC__ >= 4 && __GNUC_MINOR__ >= 7) || defined(__clang__)\n                    if (res.wait_for(chrono::milliseconds {100}) == future_status::ready) {\n#else  // #if __GNUC__ >= 4 && __GNUC_MINOR__ >= 7\n                    if (res.wait_for(chrono::milliseconds {100})) {\n#endif // #if __GNUC__ >= 4 && __GNUC_MINOR__ >= 7\n#endif // #ifdef WSRF_USE_BOOST\n                        res.get();\n                        break;\n                    } // if ()\n                } // while (true)\n\n            } catch (...) {\n\n                // make sure thread is finished\n                if (res.valid())\n                    res.get();\n\n#ifdef WSRF_USE_BOOST\n                boost::rethrow_exception(boost::current_exception());\n#else  // #ifdef WSRF_USE_BOOST\n                rethrow_exception(current_exception());\n#endif // #ifdef WSRF_USE_BOOST\n            } // try-catch\n        } // if-else\n#else  // #if defined WSRF_USE_C11 || defined WSRF_USE_BOOST;  run in sequence\n        //printf(\"start\");\n        rf.buidForestSeq(&interrupt);\n\n#endif // #if defined WSRF_USE_C11 || defined WSRF_USE_BOOST\n\n        Rcpp::List wsrf_R(WSRF_MODEL_SIZE);\n\n        if (!ispart) {\n            rf.calcEvalMeasures();\n            wsrf_R[META_IDX]        = meta_data.save();\n            wsrf_R[TARGET_DATA_IDX] = targ_data.save();\n            rf.saveMeasures(wsrf_R);\n        }\n\n        rf.saveModel(wsrf_R);  // Should be called after RForest::calcEvalMeasures().\n\n        return wsrf_R;\n\n    END_RCPP\n}\n\nSEXP afterReduceForCluster (SEXP wsrfSEXP, SEXP dsSEXP, SEXP tnSEXP) {\n    BEGIN_RCPP\n\n        Rcpp::List      wsrf_R    (wsrfSEXP);\n        Rcpp::DataFrame ds        (dsSEXP);\n        MetaData        meta_data (ds, Rcpp::as<string>(tnSEXP));\n        TargetData      targ_data (ds, &meta_data);\n        RForest         rf        (wsrf_R, &meta_data, &targ_data);\n\n        rf.calcEvalMeasures();\n\n        wsrf_R[META_IDX]        = meta_data.save();\n        wsrf_R[TARGET_DATA_IDX] = targ_data.save();\n\n        rf.saveMeasures(wsrf_R);  // Should be called after RForest::calcEvalMeasures().\n\n    END_RCPP\n}\n\nSEXP afterMergeOrSubset (SEXP wsrfSEXP) {\n    BEGIN_RCPP\n\n        Rcpp::List wsrf_R    (wsrfSEXP);\n        MetaData   meta_data (Rcpp::as<Rcpp::List>(wsrf_R[META_IDX]));\n        TargetData targ_data (Rcpp::as<Rcpp::List>(wsrf_R[TARGET_DATA_IDX]));\n        RForest    rf        (wsrf_R, &meta_data, &targ_data);\n\n        rf.calcEvalMeasures();\n\n        rf.saveMeasures(wsrf_R);  // Should be called after RForest::calcEvalMeasures().\n\n    END_RCPP\n}\n\nSEXP predict (SEXP wsrfSEXP, SEXP dsSEXP, SEXP typeSEXP) {\n\n    BEGIN_RCPP\n\n        Rcpp::List wsrf_R    (wsrfSEXP);\n        MetaData   meta_data (Rcpp::as<Rcpp::List>(wsrf_R[META_IDX]));\n        Dataset    test_set  (Rcpp::as<Rcpp::DataFrame>(dsSEXP), &meta_data, false);\n        RForest    rf        (wsrf_R, &meta_data, NULL);\n\n        string type = Rcpp::as<string>(typeSEXP);\n        if (type == \"aprob\") {\n            return rf.predictMatrix(&test_set, &RForest::predictAprobVec);\n        } else if (type == \"waprob\") {\n            return rf.predictMatrix(&test_set, &RForest::predictWAprobVec);\n        } else if (type == \"prob\") {\n            return rf.predictMatrix(&test_set, &RForest::predictProbVec);\n        } else if (type == \"vote\") {\n            return rf.predictMatrix(&test_set, &RForest::predictLabelFreqCount);\n        } else {\n            return rf.predictClassVec(&test_set);\n        }\n\n    END_RCPP\n}\n\nSEXP print (SEXP wsrfSEXP, SEXP treesSEXP) {\n    BEGIN_RCPP\n\n        Rcpp::List          wsrf_R            (wsrfSEXP);\n        MetaData            meta_data         (Rcpp::as<Rcpp::List>(wsrf_R[META_IDX]));\n        Rcpp::List          trees             (wsrf_R[TREES_IDX]);\n        Rcpp::NumericVector tree_error_rates  (wsrf_R[TREE_OOB_ERROR_RATES_IDX]);\n        Rcpp::IntegerVector tree_idx_vec      (treesSEXP);\n\n        int n = tree_idx_vec.size();\n        for (int i = 0; i < n; i++) {\n            int    index      = tree_idx_vec[i]-1;\n            double error_rate = tree_error_rates[index];\n\n            vector<vector<double> > node_infos = Rcpp::as<vector<vector<double> > >(trees[index]);\n\n            int ntests = 0;\n            int nnodes = node_infos.size();\n            for (int k = 0; k < nnodes; k++)\n                if (node_infos[k][0] == INTERNALNODE)\n                    ntests++;\n\n            if (i > 0) Rprintf(\"======================================================================\\n\");\n            Rprintf(\"Tree %d has %d tests (internal nodes), with OOB error rate %.4f:\\n\\n\", index+1, ntests, error_rate);\n\n            Tree tree (node_infos, &meta_data, error_rate);\n            tree.print();\n        }\n\n    END_RCPP\n}\n",
    "created" : 1476881119467.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3488424201",
    "id" : "4EA9500F",
    "lastKnownWriteTime" : 1476881125,
    "last_content_update" : 1476881125463,
    "path" : "C:/Users/HJJeong/Desktop/wsrf-master/src/wsrf.cpp",
    "project_path" : "src/wsrf.cpp",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}