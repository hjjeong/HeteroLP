{
    "collab_server" : "",
    "contents" : "#include \"c4_5_var_selector.h\"\n\nconst int C4p5Selector::MIN_NODE_SIZE_ = 2;  //TODO: Make it variable. original 2\n\nC4p5Selector::C4p5Selector (Dataset* train_set, TargetData* targdata, MetaData* meta_data, const vector<int>& obs_vec, const vector<int>& var_vec, unsigned seed)\n    : VarSelector(train_set, targdata, meta_data, obs_vec, var_vec) {\n    seed_ = seed;\n    info_ = calcEntropy(obs_vec);\n}\n\n/*\n * calculate corresponding information\n * if split by discrete variable <var_idx>\n */\nvoid C4p5Selector::handleDiscVar (int var_idx) {\n    /*\n     * if no more than 2 child nodes contain at least <MIN_NODE_SIZE_>\n     * instances, don't split training set by this attribute\n     */\n    map<int, vector<int> > mapper = train_set_->splitDiscVar(obs_vec_, var_idx);\n    int count = 0;\n    for (map<int, vector<int> >::iterator iter = mapper.begin(); iter != mapper.end(); ++iter)\n        if (int(iter->second.size()) >= MIN_NODE_SIZE_) count++;\n\n    if (count < 2) return;\n\n    /*\n     * calculate corresponding information gain and split entropy\n     * while split by this variable <var_idx>\n     */\n    double subinfo = 0;\n    double split_info = 0;\n    for (map<int, vector<int> >::iterator iter = mapper.begin(); iter != mapper.end(); ++iter) {\n        int nobs_sub = iter->second.size();\n        if (nobs_sub != 0) {\n            split_info += train_set_->nlogn(nobs_sub);\n            subinfo += sumNlogn(targ_data_->getLabelFreqCount(iter->second), nobs_sub);\n        }\n    }\n\n    double info_gain = info_ - subinfo/nobs_;\n    if (info_gain <= 0) return;\n\n    split_info = (train_set_->nlogn(nobs_) -  split_info) / nobs_;\n\n    cand_splits_map_[var_idx].swap(mapper);\n    info_gain_map_[var_idx] = info_gain;\n    split_info_map_[var_idx] = split_info;\n}\n\ntemplate<class T>\nvoid C4p5Selector::handleContVar (int var_idx) {\n    //TODO: Need better way to deal with different type of variable, that is DISCRETE, INTSXP, REALSXP.\n    \n    if (nobs_ < 2) return; //original 4 best 2\n\n    int min_split = (nobs_ * 0.1) / (meta_data_->nlabels());\n    if (min_split > 25) {\n        min_split = 25;\n    } else if (min_split < MIN_NODE_SIZE_) {\n        min_split = MIN_NODE_SIZE_;\n    }\n\n    vector<int> sorted_obs_vec = obs_vec_;\n    sort(sorted_obs_vec.begin(), sorted_obs_vec.end(), VarValueComparor<T>(train_set_, var_idx));\n\n    vector<int> left_dstr(meta_data_->nlabels(), 0);\n    vector<int> right_dstr = targ_data_->getLabelFreqCount(sorted_obs_vec);\n\n\n    int current_label;\n    for (int i = 0; i < min_split; ++i) {\n        current_label = targ_data_->getLabel(sorted_obs_vec[i]) - 1;\n        left_dstr[current_label]++;\n        right_dstr[current_label]--;\n    }\n\n    T* var_array = train_set_->getVar<T>(var_idx);\n    double current_value = var_array[sorted_obs_vec[min_split-1]];\n    double subinfo;\n    double split_value = -1;\n    bool subinfo_is_set = false;\n    int pos;\n    for (int i = min_split; i < nobs_ - min_split; ++i) {\n        int next_label = targ_data_->getLabel(sorted_obs_vec[i]) - 1;\n        double next_value = var_array[sorted_obs_vec[i]];\n        if (current_label != next_label && current_value != next_value) {\n            double new_subinfo = calcBisectSubinfo(left_dstr, i, right_dstr, nobs_ - i);\n            if (subinfo_is_set) {\n                if (new_subinfo < subinfo) {\n                    subinfo = new_subinfo;\n                    split_value = current_value;\n                    pos = i - 1;\n                }\n            } else {\n                subinfo = new_subinfo;\n                split_value = current_value;\n                subinfo_is_set = true;\n                pos = i - 1;\n            }\n\n        }\n        left_dstr[next_label]++;\n        right_dstr[next_label]--;\n        current_label = next_label;\n        current_value = next_value;\n    }\n\n    if (subinfo_is_set) {\n        double info_gain = info_ - subinfo;\n        if (info_gain <= 0) return;\n\n        info_gain_map_[var_idx] = info_gain;\n\n//        T* vararray = (T *) ((*train_set_)[var_idx]);\n//        double split_value = (vararray[sorted_obs_vec[pos]] + vararray[sorted_obs_vec[pos + 1]]) / 2;\n        double split_info = (train_set_->nlogn(nobs_) - train_set_->nlogn(pos + 1) - train_set_->nlogn(nobs_ - pos - 1)) / nobs_;\n        split_info_map_[var_idx] = split_info;\n        map<int, vector<int> > mapper = train_set_->splitPosition(sorted_obs_vec, pos);\n        cand_splits_map_[var_idx].swap(mapper);\n\n        split_value_map_[var_idx] = split_value;\n    }\n}\n\nvoid C4p5Selector::handleContVar (int var_idx) {\n    switch (meta_data_->getVarType(var_idx)) {\n    case INTSXP:\n        handleContVar<int>(var_idx);\n        break;\n    case REALSXP:\n        handleContVar<double>(var_idx);\n        break;\n    default:\n        throw std::range_error(\"Unexpected variable type for \" + meta_data_->getVarName(var_idx));\n    };\n}\n\n/*\n * Randomly select <nselect> variables from <var_vec>.\n * Default subspace size is log(n)/log2 + 1 if <nselect> == -1.\n */\nvector<int> C4p5Selector::getRandomVars (vector<int> var_vec, int nselect) {\n    //TODO: If possible, make similar RNG codes into a single function.\n\n    // the result attribute list can't be repeatable\n    int nleft = var_vec.size();\n    if (nselect == -1) nselect = log((double)nleft)/LN_2 + 1;\n\n    if (nselect >= nleft) return var_vec;\n\n    vector<int> result(nselect);\n\n#if defined WSRF_USE_BOOST || defined WSRF_USE_C11\n#ifdef WSRF_USE_BOOST\n    boost::random::mt19937 re(seed_);\n#else\n    default_random_engine re {seed_};\n#endif\n#else\n    Rcpp::RNGScope rngScope;\n#endif\n\n    for (int i = 0; i < nselect; ++i) {\n\n#if defined WSRF_USE_BOOST || defined WSRF_USE_C11\n#ifdef WSRF_USE_BOOST\n        boost::random::uniform_int_distribution<int> uid(0, nleft - 1);\n#else\n        uniform_int_distribution<int> uid {0, nleft - 1};\n#endif\n        int random_num = uid(re);\n#else\n        int random_num = unif_rand() * nleft;\n#endif\n\n        result[i] = var_vec[random_num];\n        var_vec[random_num] = var_vec[nleft-1];\n        nleft--;\n\n    }\n\n    return result;\n\n}\n\nvoid C4p5Selector::calcInfos (const vector<int>& var_vec, volatile bool* pInterrupt) {\n    int n = var_vec.size();\n    for (int i = 0; i < n; i++) {\n\n#if defined WSRF_USE_BOOST || defined WSRF_USE_C11\n        if (*pInterrupt){\n          printf(\"pInterrupt return\");\n          return;\n        }\n            \n#else\n        // check interruption\n        if (check_interrupt()) throw interrupt_exception(\"The random forest model building is interrupted.\");\n#endif\n\n        if (meta_data_->getVarType(var_vec[i]) == DISCRETE) {\n            handleDiscVar(var_vec[i]);\n        } else {\n            handleContVar(var_vec[i]);\n        }\n    }\n}\n\ndouble C4p5Selector::averageInfoGain () {\n    double total_info_gain = 0;\n    for (map<int, double>::iterator iter = info_gain_map_.begin(); iter != info_gain_map_.end(); ++iter)\n        total_info_gain += iter->second;\n\n    // the average_info_gain minus 0.001 to avoid the situation where all the info gain is the same\n    double average_info_gain = total_info_gain / (double) ((info_gain_map_.size())) - 0.000001;\n    return average_info_gain;\n}\n\nvoid C4p5Selector::doIGRSelection (int nvars, VarSelectRes& res, volatile bool* pInterrupt) {\n    /*\n     * calculate all information gain when split by any one of the variables\n     * from the randomly selected subspace of size <nvars>\n     */\n    calcInfos(var_vec_, pInterrupt);\n\n    if (info_gain_map_.empty()) {\n        setResult(-1, res);\n        return;\n    }\n\n    double average_info_gain = averageInfoGain();\n    \n    /*\n     * following code is IGR weighting method\n     */\n    double gain_ratio;\n    vector<int> cand_var_vec;\n    vector<double> cand_gain_ratio_vec;\n    //printf(\"nvars: %d, var_vec_size: %llu\\n\",nvars,var_vec_.size());\n    int cnt = 0;\n    // printf(\"-----------------------------------------------\\n\");\n    for (map<int, double>::iterator iter = info_gain_map_.begin(); iter != info_gain_map_.end(); ++iter) {\n        //printf(\"idx:%d, gain_ratio:%f, final_gain_ratio: %f\\n\",iter->first, iter->second, iter->second/split_info_map_[iter->first]);\n        if (iter->second >= average_info_gain) {\n            double split_info = split_info_map_[iter->first];\n            if (split_info > 0) {\n                cnt++;\n                gain_ratio = iter->second / split_info;\n                cand_var_vec.push_back(iter->first);\n                cand_gain_ratio_vec.push_back(gain_ratio);\n            }\n        }\n    }\n     //printf(\"cnt:\\n\");\n\n#if defined WSRF_USE_BOOST || defined WSRF_USE_C11\n    if (*pInterrupt) {\n        setResult(-1, res);\n        return;\n    }\n#else\n    // check interruption\n    if (check_interrupt()) throw interrupt_exception(\"The random forest model building is interrupted.\");\n#endif\n\n    int vindex;\n    if (cand_var_vec.size() == 0) {\n        vindex = info_gain_map_.begin()->first;\n        double split_info = split_info_map_[vindex];\n\n        gain_ratio = split_info > 0 ? info_gain_map_.begin()->second / split_info : NA_REAL;\n    } else {\n\n#if defined WSRF_USE_BOOST || defined WSRF_USE_C11\n        //IGR igr(cand_gain_ratio_vec, nvars, seed_);\n        newIGR igr(cand_gain_ratio_Vec, cand_var_vec, nvars, seed_);\n#else\n        //IGR igr(cand_gain_ratio_vec, nvars);\n        newIGR igr(cand_gain_ratio_vec, cand_var_vec, nvars);\n#endif\n        igr.normalizeWeight(pInterrupt);\n        int index = igr.getSelectedIdx();\n        vindex = cand_var_vec[index];\n        gain_ratio = cand_gain_ratio_vec[index];\n    }\n\n    setResult(vindex, res, gain_ratio);\n}\n\nvoid C4p5Selector::setResult (int vindex, VarSelectRes& result, double gain_ratio) {\n    if (vindex >= 0) {\n        result.ok_          = true;\n        result.var_idx_     = vindex;\n        result.split_value_ = split_value_map_[vindex];\n        result.info_gain_   = info_gain_map_[vindex];\n        result.split_info_  = split_info_map_[vindex];\n        result.gain_ratio_  = gain_ratio;\n        result.split_map_.swap(cand_splits_map_[vindex]);\n    } else {\n        result.ok_ = false;\n    }\n}\n\nvoid C4p5Selector::doSelection (int nvars, VarSelectRes& res, volatile bool* pInterrupt) {\n    /*\n     * calculate all information gain when split by any one of the variables\n     * from the randomly selected subspace of size <nvars>\n     */\n\n    vector<int> subvar_vec = getRandomVars(var_vec_, nvars);\n\n    calcInfos(subvar_vec, pInterrupt);\n\n    if (info_gain_map_.empty()) {\n        setResult(-1, res);\n        return;\n    }\n\n    /*\n     * find the best variable\n     */\n    double average_info_gain = averageInfoGain();\n    double gain_ratio = -1;\n    int vindex = -1;\n    bool is_set_gain_ratio = false;\n    for (map<int, double>::iterator iter = info_gain_map_.begin(); iter != info_gain_map_.end(); ++iter) {\n\n#if defined WSRF_USE_BOOST || defined WSRF_USE_C11\n        if (*pInterrupt) {\n            setResult(-1, res);\n            return;\n        }\n#else\n        // check interruption\n        if (check_interrupt()) throw interrupt_exception(\"The random forest model building is interrupted.\");\n#endif\n\n        if (iter->second >= average_info_gain) {\n            double split_info = split_info_map_[iter->first];\n            if (split_info > 0) {\n                double new_gain_ratio = iter->second / split_info;\n                if (is_set_gain_ratio) {\n                    if (new_gain_ratio > gain_ratio) {\n                        gain_ratio = new_gain_ratio;\n                        vindex     = iter->first;\n                    }\n                } else {\n                    gain_ratio = new_gain_ratio;\n                    vindex     = iter->first;\n                    is_set_gain_ratio = true;\n                }\n            }\n        }\n    }\n\n    if (!is_set_gain_ratio) {\n        vindex     = info_gain_map_.begin()->first;\n        double split_info = split_info_map_[vindex];\n        gain_ratio = split_info > 0 ? info_gain_map_.begin()->second / split_info : NA_REAL;\n    }\n\n    setResult(vindex, res, gain_ratio);\n}\n\n",
    "created" : 1476880724982.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2410349825",
    "id" : "83C5E97E",
    "lastKnownWriteTime" : 1476880737,
    "last_content_update" : 1476880737377,
    "path" : "C:/Users/HJJeong/Desktop/wsrf-master/src/c4_5_var_selector.cpp",
    "project_path" : "src/c4_5_var_selector.cpp",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}