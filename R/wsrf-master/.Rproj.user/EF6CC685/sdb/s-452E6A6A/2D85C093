{
    "collab_server" : "",
    "contents" : "#include \"newIGR.h\"\n\n#if defined WSRF_USE_BOOST || defined WSRF_USE_C11\nnewIGR::newIGR(const vector<double>& gain_ratio, const vector<int>& can_var_vec,int nvars, unsigned seed)\n#else\nnewIGR::newIGR(const vector<double>& gain_ratio, const vector<int>& can_var_vec, int nvars)\n#endif\n  :can_var_vec_(can_var_vec), gain_ratio_vec_(gain_ratio)\n  {\n    double arr[] = {0.060326388,0.256351506,0.178243939,0.561994291,0.338892245,0.540865494,0.791381954,0.060326388,0.556920311,0.526640388,0.526640388,0.526640388,0.526640388};\n    typecorr = vector<double> (sizeof(arr));\n    for(int i=0; i<sizeof(arr); i++){\n      typecorr.push_back(arr[i]);\n    }\n    \n    weights_ = vector<double>(can_var_vec.size()+1);\n    wst_     = vector<int>(can_var_vec.size()+1);\n#if defined WSRF_USE_BOOST || defined WSRF_USE_C11\n    seed_    = seed;\n#endif\n\n    int n = can_var_vec.size();\n    if (nvars == -1) nvars = log((double)n) / LN_2 + 1;\n    nvars_ = nvars >= n ? n : nvars;\n}\n\nint newIGR::weightedSampling(int rand_num) {\n    int i = 1;\n    \n    while (rand_num > weights_[i]) {\n        rand_num -= weights_[i];\n        i <<= 1;\n        if (rand_num > wst_[i]) {\n            rand_num -= wst_[i];\n            i++;\n        }\n    }\n\n    int res = i-1;\n    int w = weights_[i];\n    weights_[i] = 0;\n\n    while (i != 0) {\n        wst_[i] -= w;\n        i >>= 1;\n    }\n\n    return res;\n\n//    //may be the largest right is smaller RAND_MAX,because double to int may lose information\n//    return n - 1;\n}\n\n/*\n * generate an integer list of size <size> according to probability\n * that is, select <size> variables by their weights\n */\nvector<int> newIGR::getRandomWeightedVars() {\n\n    //TODO: If possible, make similar RNG codes into a single function.\n\n    int n = weights_.size()-1;\n    vector<int> result(nvars_ >= n ? n : nvars_);\n\n    if (nvars_ >= n) {\n        for (int i = 0; i < n; i++)\n            result[i] = i;\n        return result;\n    }\n\n#if defined WSRF_USE_BOOST || defined WSRF_USE_C11\n#ifdef WSRF_USE_BOOST\n    boost::random::mt19937 re(seed_);\n#else\n    default_random_engine re {seed_};\n#endif\n#else\n    Rcpp::RNGScope rngScope;\n#endif\n\n    for(int i = 0; i < nvars_; ++ i) {\n\n#if defined WSRF_USE_BOOST || defined WSRF_USE_C11\n#ifdef WSRF_USE_BOOST\n        boost::random::uniform_int_distribution<int> uid(0, wst_[1]-1);\n#else\n        uniform_int_distribution<int> uid {0, wst_[1]-1};\n#endif\n        result[i] = weightedSampling(uid(re));\n#else\n        result[i] = weightedSampling(unif_rand() * wst_[1]);\n#endif\n\n    }\n\n    return result;\n}\n\n/*\n * calculate weights of all variables according to their gain ratios\n * the results are in this->weights_\n */\nvoid newIGR::normalizeWeight(volatile bool* pInterrupt) {\n\n    double sum = 0;\n    int n = can_var_vec_.size();\n    \n    for (int i = 0, j = 1; i < n; i++, j++) {\n\n#if defined WSRF_USE_BOOST || defined WSRF_USE_C11\n        if (*pInterrupt)\n            return;\n#else\n        // check interruption\n        if (check_interrupt()) throw interrupt_exception(\"The random forest model building is interrupted.\");\n#endif\n        //printf(\"typecorr size: %d\\n\",sizeof(typecorr));\n        //printf(\"can_var_vec[i]: %d\\n\",can_var_vec_[i]);\n        //printf(\"typecr(c):%f\\n\",typecorr[8]);\n        //printf(\"typecorr(can): %f\\n\", typecorr[can_var_vec_[i]]);\n        weights_[j] = typecorr[can_var_vec_[i]];\n        \n        //printf(\"typecorr can_var_Vec_:%f \",typecorr[can_var_vec_[i]]);\n        if(weights_[j]==0){\n          weights_[j]=0.003;\n        }\n        sum += weights_[j];\n    }\n    // printf(\"\\n\");\n    \n    if (sum != 0) {\n        for (int i = 1; i <= n; i++) {\n            // printf(\"weight:%f \\n\",weights_[i]);\n            weights_[i] /= sum;\n            int temp = weights_[i] * RAND_MAX;\n            // printf(\"n: %d, normalize weights: %f, count: %d\\n\",n, weights_[i], temp); //RAND_MAX: 32767\n            \n            weights_[i] = temp;\n            wst_[i] = temp;\n        }\n    } else {\n        int temp = RAND_MAX / (double) n;\n        for (int i = 1; i <= n; i++) {\n            weights_[i] = temp;\n            wst_[i] = temp;\n            printf(\"count: %d\\n\",temp);\n        }\n    }\n\n    for (int i = n; i > 1; i--) {\n        wst_[i>>1] += wst_[i];\n        //printf(\"i: %d wst_: %d\\n\",i,wst_[i]);\n    }\n}\n\n/*\n * select the most weighted variable from < this->m_ > variables that\n * are randomly picked from all varialbes according to their weights\n */\n\nint newIGR::getSelectedIdx() {\n  const vector<int>& wrs_vec = getRandomWeightedVars();\n  int max = -1;\n  bool is_max_set = false;\n  for (int i = 0, rand_num; i < nvars_; i++) {\n    rand_num = wrs_vec[i];\n    if (is_max_set) {\n      if (gain_ratio_vec_[rand_num] >= gain_ratio_vec_[max]) max = rand_num;\n    } else {\n      max = rand_num;\n      is_max_set = true;\n    }\n  }\n  // printf(\"getSelectedIdx: %d\\n\",max);\n  return max;\n}\n// int newIGR::getSelectedIdx() {\n//     const vector<int>& wrs_vec = getRandomWeightedVars();\n//     int max = -1;\n//     bool is_max_set = false;\n//     for (int i = 0, rand_num; i < nvars_; i++) {\n//         rand_num = wrs_vec[i];\n//         if (is_max_set) {\n//             if (weights_[can_var_vec_[rand_num]] >= weights_[can_var_vec_[max]]) max = rand_num;\n//         } else {\n//             max = rand_num;\n//             is_max_set = true;\n//         }\n//     }\n//     printf(\"getSelectedIdx: %d\\n\",max);\n//     return max;\n// }\n",
    "created" : 1476849465336.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1474610965",
    "id" : "2D85C093",
    "lastKnownWriteTime" : 1486033619,
    "last_content_update" : 1486033619781,
    "path" : "C:/Users/HJJeong/Desktop/wsrf-master/src/newIGR.cpp",
    "project_path" : "src/newIGR.cpp",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}